/*******************************************************************************
 * Copyright (c) 2015 OpenDSE
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *******************************************************************************/
package net.sf.opendse.generator;

import static java.lang.Math.min;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import net.sf.opendse.model.Application;
import net.sf.opendse.model.Communication;
import net.sf.opendse.model.Dependency;
import net.sf.opendse.model.ICommunication;
import net.sf.opendse.model.Task;

/**
 * The {@code ApplicationGenerator} contains several methods to generate and
 * transform applications.
 * 
 * @author lukasiewycz
 * 
 */
public class ApplicationGenerator extends Generator {

	protected IdProvider taskId;
	protected IdProvider commId;
	protected IdProvider dependencyId;

	/**
	 * Constructs an {@code ApplicationGenerator} with a random seed.
	 */
	public ApplicationGenerator() {
		this(System.currentTimeMillis());
	}

	/**
	 * Constructs an {@code ApplicationGenerator} with a given seed.
	 * 
	 * @param seed
	 *            the seed
	 */
	public ApplicationGenerator(long seed) {
		this(seed, new IdProvider("p"), new IdProvider("c"), new IdProvider("d"));
	}

	/**
	 * Constructs an {@code ApplicationGenerator}.
	 * 
	 * @param seed
	 *            the seed
	 * @param taskId
	 *            the provider for the task ids
	 * @param commId
	 *            the provider for the communication ids
	 * @param dependencyId
	 *            the proider for the dependency ids
	 */
	public ApplicationGenerator(long seed, IdProvider taskId, IdProvider commId, IdProvider dependencyId) {
		super(new Random(seed));
		this.taskId = taskId;
		this.commId = commId;
		this.dependencyId = dependencyId;
	}

	/**
	 * Returns an application generated by the TGFF algorithm (old).
	 * 
	 * @param x
	 *            the minimal number of tasks
	 * @param id
	 *            the maximum in-degree
	 * @param od
	 *            the maximum out-degree
	 * @return the application
	 */
	public Application<Task, Dependency> generate(int x, int id, int od) {
		Application<Task, Dependency> application = new Application<Task, Dependency>();
		{
			Task task = new Task(taskId.next());
			application.addVertex(task);
		}

		while (application.getVertexCount() < x) {
			if (random.nextBoolean()) {
				// fan-in
				List<Task> candidates = new ArrayList<Task>();
				for (Task task : application) {
					if (application.getSuccessorCount(task) < od) {
						candidates.add(task);
					}
				}

				int q = candidates.size();
				assert (q > 0);

				int o = min(candidates.size(), min(application.getVertexCount(), id));
				int z = rand(0, o);

				if (z > 0) {
					while (candidates.size() > z) {
						candidates.remove(rand(candidates));
					}

					Task task = new Task(taskId.next());
					for (Task c : candidates) {
						Dependency dependency = new Dependency(dependencyId.next());
						application.addEdge(dependency, c, task);
					}
				}

			} else {
				// fan-out
				int minDegree = Integer.MAX_VALUE;
				List<Task> candidates = new ArrayList<Task>();
				for (Task task : application) {
					int d = application.getOutEdges(task).size();
					if (d < minDegree) {
						minDegree = d;
						candidates.clear();
					}
					if (d == minDegree) {
						candidates.add(task);
					}
				}

				if (minDegree < od) {
					Task p = rand(candidates);
					int r = od - application.getSuccessorCount(p);
					int y = rand(0, r);

					for (int i = 0; i < y; i++) {
						Task task = new Task(taskId.next());
						Dependency dependency = new Dependency(dependencyId.next());
						application.addEdge(dependency, p, task);
					}
				}
			}
		}

		return application;
	}

	/**
	 * Adds communication tasks between process tasks.
	 * 
	 * @param application
	 *            the application
	 * @param min
	 *            the minimal number of receivers of a communication
	 * @param max
	 *            the maximal number of receivers of a communicatoin
	 */
	public void insertCommunication(Application<Task, Dependency> application, int min, int max) {

		Set<Task> tasks = new HashSet<Task>(application.getVertices());

		for (Task task : tasks) {
			List<Dependency> edges = new ArrayList<Dependency>(application.getOutEdges(task));

			for (Dependency edge : new ArrayList<Dependency>(edges)) {
				if (application.getDest(edge) instanceof ICommunication) {
					edges.remove(edge);
				}
			}

			while (!edges.isEmpty()) {
				int x = rand(min, max);
				List<Dependency> targets = new ArrayList<Dependency>();

				while (!edges.isEmpty() && targets.size() < x) {
					Dependency edge = rand(edges);
					edges.remove(edge);
					targets.add(edge);
				}

				Task comm = new Communication(commId.next());
				Dependency e = new Dependency(dependencyId.next());
				application.addEdge(e, task, comm);

				for (Dependency edge : targets) {
					Task t = application.getDest(edge);
					application.removeEdge(edge);
					application.addEdge(edge, comm, t);
				}
			}
		}
	}
	
	public Application<Task, Dependency> merge(Collection<Application<Task, Dependency>> applications) {
		Application<Task, Dependency> application = new Application<Task, Dependency>();
		for (Application<Task, Dependency> appl : applications) {
			for (Task task : appl.getVertices()) {
				application.addVertex(task);
			}
			for (Dependency dependency : appl.getEdges()) {
				application.addEdge(dependency, appl.getEndpoints(dependency), appl.getEdgeType(dependency));
			}
		}
		return application;
	}

	public Application<Task, Dependency> merge(Application<Task, Dependency>... applications) {
		Collection<Application<Task, Dependency>> apps = Arrays.asList(applications);
		return merge(apps);
	}

}
