import numpy as np


def GetTFLiteClass(cls):

    """The automatically generated schema helper modules and the classes contained within are
    somewhat awkward to access as the module containing folder is walked, modules are imported,
    and then contained classes are added to sys.modules for the respective file.

    Thus, accessing classes is done via sys.modules["tflite"].$CLASS_NAME.$CLASSNAME, this
    function simply makes this process more human readable.
    :type cls: str
    :param cls: The name of the TFLite class that you wish to access

    :raises: None

    :rtype: The required class' type
    """
    import sys

    return eval('sys.modules["tflite"].{}.{}'.format(cls, cls))


def ClassCodeToName(cls, code):
    """Returns the string identifier used to reference a numeric value in a class.

    Parameters
    ---------
    cls  : The class we are to search through.
    code : The numeric value that is associated with the target identifier

    Returns
    ---------
    string

    This class is generated by the flatbuffer compiler when compiling a flattbuffer
    enum. As flattbuffer enums do not compile into the common Python enum. we cannot
    easily access the string identifier and as such must search through the class
    to find the appropriate string identifier and return it if found.

    This is useful when wanting to resolve things such as op codes into values we
    can use for generating function names that need to be called for processing
    schema objects.
    """
    for name, value in cls.__dict__.items():
        if value == code:
            return name
    return None


def GetOpNameFromOperator(model, operator) -> str:

    """Flattbuffers store each operator as an index with a builtin code that then resolves
    in the model's OperatorCodes to provide a opcode that can be converted to a string name
    using the BuiltinOperator class. This function simplifies this process.
    :type model: tflite.Model.Model
    :param model: The model from which the operator should be retrieved

    :type operator: tflite.Operator.Operator
    :param operator: The Operator that is to be resolved into a string name

    :raises:

    :rtype: str
    """
    operator_index = operator.OpcodeIndex()
    operator_model_code = model.OperatorCodes(operator_index)
    operator_builtin_code = operator_model_code.BuiltinCode()

    return ClassCodeToName(GetTFLiteClass("BuiltinOperator"), operator_builtin_code)


def GetOptionsNameFromOperator(operator) -> str:

    """Resolved the name of an operator's option's class name
    :type operator: The operator whos options should be resolved
    :param operator: tflite.Operator.Operator

    :raises:

    :rtype: str
    """
    options_type_code = operator.BuiltinOptionsType()
    return ClassCodeToName(GetTFLiteClass("BuiltinOptions"), options_type_code)


def InitOptionsClass(options_class_name, options_fb_table):

    """The flattbuffer helper modules generate modules for each layer type and their options.
    To properly access the options of a layer one must init one of these modules, thus one needs
    the name of the layer's options' class and the flattbuffer table that contains the information
    we wish to parse into the options class.

    :type options_class_name: str
    :param options_class_name: The string name of the options' class

    :type options_fb_table: flatbuffers.table.Table
    :param options_fb_table: Flattbuffer table containing the options' values

    :raises:

    :rtype: An instantiated and populated instance of the respective layer options class
    """
    options_class = GetTFLiteClass(options_class_name)()
    options_class.Init(options_fb_table.Bytes, options_fb_table.Pos)

    return options_class


def GetOptions(options_class) -> dict:

    """Parses an initiated options class and returns a dictionary containing all the options'
    names as keys with the appropriate values stored as well
    :type options_class: options class
    :param options_class: Initialized options class

    :raises:

    :rtype: dict
    """

    import re

    options_name = options_class.__class__.__name__

    options = [
        func
        for func in dir(options_class)
        if callable(getattr(options_class, func))
        and re.search(r"^((?!Init)(?!__)(?!{}).)*$".format(options_name), func)
    ]

    opts = {}
    for method in options:
        opts[method] = eval("options_class.{}()".format(method))

    return opts


def GetOperatorInputOutputLengths(operator):

    """Description
    :type operator:
    :param operator:

    :raises:

    :rtype:
    """
    return (operator.InputsLength(), operator.OutputsLength())


def GetInputShape(input_tensors) -> np.ndarray:

    """Description
    :type input_tensors:
    :param input_tensors:

    :raises:

    :rtype:
    """
    return input_tensors[0][0]


def GetOutputShape(output_tensors) -> np.ndarray:

    """Description
    :type output_tensors:
    :param output_tensors:

    :raises:

    :rtype:
    """
    return output_tensors[0][0]


def GetStrides(options) -> list:

    """Description
    :type options:
    :param options:

    :raises:

    :rtype:
    """
    return [1, options["StrideH"], options["StrideW"], 1]


def GetPadding(options) -> str:

    """Description
    :type options:
    :param options:

    :raises:

    :rtype:
    """
    return ClassCodeToName(GetTFLiteClass("Padding"), options["Padding"])


def GetActivationFunction(options):

    """Description
    :type options:
    :param options:

    :raises:

    :rtype:
    """

    funcs = {"RELU": "relu", "SOFTMAX": "softmax", "DROPOUT": None}

    return funcs.get(
        ClassCodeToName(
            GetTFLiteClass("ActivationFunctionType"),
            options["FusedActivationFunction"],
        ),
        None,
    )


def GetWeightsFormat(options):

    """Description
    :type options:
    :param options:

    :raises:

    :rtype:
    """
    return options["WeightsFormat"]


def GetTensorType(tensor) -> type:

    """Description
    :type tensor:
    :param tensor:

    :raises:

    :rtype:
    """
    import tensorflow as tf

    type_str = tensor[1]

    if type_str == "FLOAT32":
        return tf.float32
    elif type_str == "FLOAT16":
        return tf.float16
    elif type_str == "INT32":
        return tf.int32
    elif type_str == "UINT8":
        return tf.uint8
    elif type_str == "INT64":
        return tf.int64
    elif type_str == "INT16":
        return tf.int16
    elif type_str == "INT8":
        return tf.int8
    else:
        raise Exception(TypeError)


def GetInputType(input_tensors) -> type:

    """Description
    :type input_tensors:
    :param input_tensors:

    :raises:

    :rtype:
    """
    import tensorflow as tf
    from utils.tflite_helper import GetTensorType

    return GetTensorType(input_tensors[0])
